void Command::handlePrivMsg(Client& client, const std::string& args, std::map<std::string, Channel*>& channels) {
    (void)channels;

    // Checks if the Client is already authenticated
    if (!client.isAuthenticated() || client.nickname.empty() || client.username.empty()) {
        client.sendMessage(ERR_NOTREGISTERED);
        return;
    }

    // Find the position of the colon that indicates the start of the message
    size_t colonPos = args.find(" :");
    if (colonPos == std::string::npos) {
        client.sendMessage(ERR_NEEDMOREPARAMS("PRIVMSG"));
        return;
    }

    // Extract the targets and the message
    std::string targetsStr = args.substr(0, colonPos);
    std::string message = args.substr(colonPos + 2); // Skip the " :"

    // Split the targets by comma
    std::vector<std::string> targets;
    std::stringstream stream(targetsStr);
    std::string target;
    while (std::getline(stream, target, ',')) {
        targets.push_back(trim(target));
    }

    // Debug print to check the targets and the message
    for (size_t i = 0; i < targets.size(); ++i) {
        std::cout << "Target [" << i << "]: " << targets[i] << std::endl;
    }
    std::cout << "Message: " << message << std::endl;

    // Send the message to each target
    for (std::vector<std::string>::iterator it = targets.begin(); it != targets.end(); ++it) {
        std::string target = *it;
        if (target[0] == '#') {
            // Send to channel
            Channel* channel = channels[target];
            if (channel) {
                channel->broadcast(client.nickname + ": " + message, &client);
            } else {
                client.sendMessage(ERR_NOSUCHCHANNEL(target));
            }
        } else {
            // Send to individual client
            std::map<int, Client*>& clients = _server.getClients();
            bool found = false;
            for (std::map<int, Client*>::iterator it = clients.begin(); it != clients.end(); ++it) {
                if (it->second->nickname == target) {
                    it->second->sendMessage(client.nickname + ": " + message);
                    found = true;
                    break;
                }
            }
            if (!found) {
                client.sendMessage(ERR_NOSUCHNICK(target));
            }
        }
    }
}